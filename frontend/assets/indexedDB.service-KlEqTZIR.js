var D=Object.defineProperty;var w=(l,t,r)=>t in l?D(l,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):l[t]=r;var y=(l,t,r)=>w(l,typeof t!="symbol"?t+"":t,r);import{aA as I,aB as u,aC as a,aD as c}from"./index-BlVR3GtE.js";const f=1;class B{constructor(){y(this,"db",null);y(this,"isDbInitializing",!1)}async initDB(){if(!(this.db||this.isDbInitializing))return this.isDbInitializing=!0,new Promise((t,r)=>{const n=indexedDB.open(I,f);n.onerror=()=>{this.isDbInitializing=!1,r(n.error)},n.onsuccess=()=>{this.db=n.result,this.isDbInitializing=!1,this.db.onclose=()=>{console.warn("IndexedDB connection closed unexpectedly."),this.db=null},t()},n.onupgradeneeded=o=>{const s=o.target.result;s.objectStoreNames.contains(u)||s.createObjectStore(u,{keyPath:"subBookId"}),s.objectStoreNames.contains(a)||s.createObjectStore(a,{keyPath:"journeyId"}).createIndex("parent","parent",{unique:!1}),s.objectStoreNames.contains(c)||s.createObjectStore(c,{keyPath:"articleIdInJourney"})}})}async saveSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const e=this.db.transaction([u],"readwrite").objectStore(u).put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const e=this.db.transaction([u],"readonly").objectStore(u).get(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r(e.result)})}async removeSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const e=this.db.transaction([u],"readwrite").objectStore(u).delete(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async saveJourneys(t){return this.db||await this.initDB(),new Promise((r,n)=>{const s=this.db.transaction([a],"readwrite").objectStore(a);let e=0;t.forEach(i=>{const d={...i,journeyId:i._id},b=s.put(d);b.onsuccess=()=>{e++,e===t.length&&r()},b.onerror=()=>n(b.error)})})}async getJourneyCards(t){return this.db||await this.initDB(),new Promise((r,n)=>{const i=this.db.transaction([a],"readonly").objectStore(a).index("parent").getAll(t);i.onerror=()=>n(i.error),i.onsuccess=()=>r(i.result)})}async removeJourneyInfo(t){this.db||await this.initDB();const r=[t],n=async o=>{const e=this.db.transaction([a],"readwrite").objectStore(a),d=e.index("parent").openCursor(IDBKeyRange.only(o));d.onerror=()=>{throw new Error("Error while accessing IndexedDB")},d.onsuccess=b=>{const h=b.target.result;h&&(r.push(h.primaryKey),e.delete(h.primaryKey),n(h.primaryKey),h.continue())}};return await n(t),r}async saveArticleInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const s=this.db.transaction([c],"readwrite").objectStore(c);let e=0;t.forEach(i=>{const d=s.put(i);d.onsuccess=()=>{e++,e===t.length&&r()},d.onerror=()=>n(d.error)})})}async getArticleInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const e=this.db.transaction([c],"readonly").objectStore(c).get(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r(e.result)})}async removeArticleInfo(t){return this.db||await this.initDB(),new Promise((r,n)=>{const e=this.db.transaction([c],"readwrite").objectStore(c).delete(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getAllJourneyIds(){return this.db||await this.initDB(),new Promise((t,r)=>{const s=this.db.transaction([a],"readonly").objectStore(a).getAllKeys();s.onerror=()=>r(s.error),s.onsuccess=()=>t(s.result)})}async getAllArticleIds(){return this.db||await this.initDB(),new Promise((t,r)=>{const s=this.db.transaction([c],"readonly").objectStore(c).getAllKeys();s.onerror=()=>r(s.error),s.onsuccess=()=>t(s.result)})}}const g=new B;export{g as i};
