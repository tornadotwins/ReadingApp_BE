var D=Object.defineProperty;var w=(l,t,r)=>t in l?D(l,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):l[t]=r;var y=(l,t,r)=>w(l,typeof t!="symbol"?t+"":t,r);import{aA as I,aB as u,aC as a,aD as c}from"./index-BlVR3GtE.js";const f=1;class B{constructor(){y(this,"db",null);y(this,"isDbInitializing",!1)}async initDB(){if(!(this.db||this.isDbInitializing))return this.isDbInitializing=!0,new Promise((t,r)=>{const s=indexedDB.open(I,f);s.onerror=()=>{this.isDbInitializing=!1,r(s.error)},s.onsuccess=()=>{this.db=s.result,this.isDbInitializing=!1,this.db.onclose=()=>{console.warn("IndexedDB connection closed unexpectedly."),this.db=null},t()},s.onupgradeneeded=o=>{const n=o.target.result;n.objectStoreNames.contains(u)||n.createObjectStore(u,{keyPath:"subBookId"}),n.objectStoreNames.contains(a)||n.createObjectStore(a,{keyPath:"journeyId"}).createIndex("parent","parent",{unique:!1}),n.objectStoreNames.contains(c)||n.createObjectStore(c,{keyPath:"articleIdInJourney"})}})}async saveSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const e=this.db.transaction([u],"readwrite").objectStore(u).put(t);e.onerror=()=>s(e.error),e.onsuccess=()=>r()})}async getSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const e=this.db.transaction([u],"readonly").objectStore(u).get(t);e.onerror=()=>s(e.error),e.onsuccess=()=>r(e.result)})}async removeSubBookInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const e=this.db.transaction([u],"readwrite").objectStore(u).delete(t);e.onerror=()=>s(e.error),e.onsuccess=()=>r()})}async saveJourneys(t){return this.db||await this.initDB(),new Promise((r,s)=>{const n=this.db.transaction([a],"readwrite").objectStore(a);let e=0;t.forEach(i=>{const d={...i,journeyId:i._id},b=n.put(d);b.onsuccess=()=>{e++,e===t.length&&r(),console.log("journey: ",e)},b.onerror=()=>s(b.error)})})}async getJourneyCards(t){return this.db||await this.initDB(),new Promise((r,s)=>{const i=this.db.transaction([a],"readonly").objectStore(a).index("parent").getAll(t);i.onerror=()=>s(i.error),i.onsuccess=()=>r(i.result)})}async removeJourneyInfo(t){this.db||await this.initDB();let r=[t];const s=async o=>{const e=this.db.transaction([a],"readwrite").objectStore(a),d=e.index("parent").openCursor(IDBKeyRange.only(o));d.onerror=()=>{throw new Error("Error while accessing IndexedDB")},d.onsuccess=b=>{const h=b.target.result;h&&(r=[...r,h.primaryKey],e.delete(h.primaryKey),s(h.primaryKey),h.continue())}};return await s(t),r}async saveArticleInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const n=this.db.transaction([c],"readwrite").objectStore(c);let e=0;t.forEach(i=>{const d=n.put(i);d.onsuccess=()=>{e++,e===t.length&&r(),console.log("article: ",e)},d.onerror=()=>s(d.error)})})}async getArticleInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const e=this.db.transaction([c],"readonly").objectStore(c).get(t);e.onerror=()=>s(e.error),e.onsuccess=()=>r(e.result)})}async removeArticleInfo(t){return this.db||await this.initDB(),new Promise((r,s)=>{const e=this.db.transaction([c],"readwrite").objectStore(c).delete(t);e.onerror=()=>s(e.error),e.onsuccess=()=>r()})}async getAllJourneyIds(){return this.db||await this.initDB(),new Promise((t,r)=>{const n=this.db.transaction([a],"readonly").objectStore(a).getAllKeys();n.onerror=()=>r(n.error),n.onsuccess=()=>t(n.result)})}async getAllArticleIds(){return this.db||await this.initDB(),new Promise((t,r)=>{const n=this.db.transaction([c],"readonly").objectStore(c).getAllKeys();n.onerror=()=>r(n.error),n.onsuccess=()=>t(n.result)})}}const g=new B;export{g as i};
